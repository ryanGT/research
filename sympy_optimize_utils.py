"""This module contains functions for running optimization on
closed-form symbolic Bodes generated by sympy."""

from pylab import *
from scipy import *
from scipy import optimize

from rwkmisc import my_import

import time, copy

import SFLR_TMM
reload(SFLR_TMM)

import rwkbode

import sympy_bodes_tau
func1 = sympy_bodes_tau.Bodes

import sympy_bode_analysis
from sympy_bode_analysis import calc_and_massage_Bodes

#import exp_data
#fexp = exp_data.f
#th_v_exp = exp_data.th_v_exp
#a_v_exp = exp_data.a_v_exp
data_mod_name = 'swept_sine_amp_75_July_07_2009_log_downsampled'

import load_exp_data

fexp, th_v_exp, a_v_exp, a_th_exp = load_exp_data.load_data(data_mod_name)

from rwkdataproc import thresh
ind1 = thresh(fexp,5)

log_file = 'sympy_param_log_w_base_mass_12_terms_w_con_dict.txt'
keys = ['b_I','b_m','k_spring','c_spring','K_act','p_act1', \
        'mu','EI','a_m','k_clamp','c_clamp','c_beam']

labels = keys + ['error', 'p1', 'p2']
N = len(labels)

def _set_vals(x, params, param_names):
    """Set the values of parameters param_names in the SLFR_params
    instance params with the values from x.  This is done to allow
    SLFR_params instances to be used with optimize.fmin."""
    for val, attr in zip(x, param_names):
        setattr(params, attr, val)
    return params

def _get_vals(params, param_names):
    xout = None
    for attr in param_names:
        val = getattr(params, attr)
        if xout is None:
            xout = [val]
        else:
            xout.append(val)
    return xout


def _cost(params, extra=0, func=func1, con_dict={}, \
          penalty=1e5):
    """A constrained cost function.  cond_dict is a dictionary whose
    keys are attributes of params and whose values are (min, max)
    constraint tuples."""
    phaseweight = 0.0
    th_bode, a_bode = calc_and_massage_Bodes(fexp, params, \
                                             func=func)
    db_e = abs(th_v_exp.dBmag()-th_bode.dBmag()) + \
          abs(a_v_exp.dBmag()-a_bode.dBmag())
    e = sum(db_e)

    if phaseweight > 0.0:
        phase_e = abs(th_v_exp.phase-th_bode.phase) + \
                  abs(a_v_exp.phase-a_bode.phase)
        e += phaseweight*sum(phase_e)

    #penalize for violating constraints
    for name, con in con_dict.iteritems():
        val = getattr(params, name)
        if val < min(con):
            e += penalty
        elif val > max(con):
            e += penalty

    if extra:
        return e, th_bode, a_bode
    else:
        return e
    
    
def mycost(x, params, param_names, func=func1, \
           con_dict={}):
    params = _set_vals(x, params, param_names)
    return _cost(params, func=func, con_dict=con_dict)

def myoptimize(params_in, param_names=['k_clamp','c_clamp'], \
               func=func1, con_dict={'k_clamp':(0,1000)}):
    """Optimize the parameters of the SLFR_params instance params_in
    listed in param_names (i.e. don't try and optimize all of the
    parameters, only those listed in param_names).  Use func to
    calculate the Bodes.  func should be a closed-form function from
    sympy that returns the Bodes."""
    params = copy.copy(params_in)
    ig = _get_vals(params, param_names)
    x = optimize.fmin(mycost, ig, args=(params, param_names, func, \
                                        con_dict))
    return _set_vals(x, params, param_names)

def make_list(min, max, N):
    dp = (max-min)/(N-1)
    mylist = arange(min, max+dp/2, dp)
    return mylist

def str_out(string):
    f = open(log_file,'ab')
    f.write(string)
    f.close()
    
def row_of_strings_out(row):
    assert(len(row)==N), "Got a row of bad length:len(row)=" + \
                         str(len(row))
    row_str = '\t'.join(row) +'\n'
    str_out(row_str)
    return row_str

def row_of_floats_out(row, fmt='%0.8g'):
    string_list = [fmt % item for item in row]
    row_str = row_of_strings_out(string_list)
    return row_str

def build_param_list(params):
    mylist = [getattr(params, item) for item in labels[0:-3]]
    return mylist

def save_row(params, e, z1, z2):
    param_list = build_param_list(params)
    row = param_list + [e, z1, z2]
    row_of_floats_out(row)
    return row


def find_zeros(th_bode):
    dB = th_bode.dBmag()
    i1 = argmin(dB[0:ind1])
    i2 = argmin(dB[ind1:])+ind1
    z1 = fexp[i1]
    z2 = fexp[i2]
    return z1, z2

def find_peaks(a_bode):
    dB = a_bode.dBmag()
    i1 = argmax(dB[0:ind1])
    i2 = argmax(dB[ind1:])+ind1
    z1 = fexp[i1]
    z2 = fexp[i2]
    return z1, z2


def spreadsheet_row_to_params(rowin, pklname=None):
    keys = labels[0:-3]
    if pklname is not None:
        params = SFLR_TMM.load_params(pklname)
    else:
        params = SFLR_TMM.new_def_params()
    for key, val in zip(keys, rowin[0:-3]):
        setattr(params, key, val)
    return params
