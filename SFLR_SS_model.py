from pylab import *
from scipy import *
from scipy import linalg, signal

import controls

import rwkmisc, rwkbode

from IPython.Debugger import Pdb

import copy

import SFLR_TF_models
reload(SFLR_TF_models)

class SS_model(object):
    def __init__(self, A, B, C, D=0.0):
        self.A = A
        self.B = B
        self.C = C
        self.D = D
        nr,nc = A.shape
        self.N = nr

    def check_pole_locations(self, K):
        """Find the pole locations that would result from using
        feedback vector K."""
        Atemp = self.A + dot(rwkmisc.colwise(self.B), K)
        poles = linalg.eigvals(Atemp)
        return poles


    def find_poles(self):
        return linalg.eigvals(self.A)


    def phi_des_of_A(self, descoeffs):
        """Evalute the charcteristic polynominal using
        descoeffs[0]*A**n+descoeffs[1]*A**(n-1)"""
        N = len(descoeffs)-1
        assert N == self.N, "bad length of descoeffs"
        for n in range(N+1):
            a_n = descoeffs[N-n]
            if n == 0:
                phi = eye(N)*a_n
            else:
                if n == 1:
                    An = self.A
                else:
                    An = dot(An,self.A)
                phi += An*a_n
        return phi


    def controlability(self):
        N = self.N
        for n in range(N):
            if n == 0:
                collist = [self.B]
            else:
                if n == 1:
                    An = self.A
                else:
                    An = dot(An,self.A)
                curcol = dot(An, self.B)
                collist.append(curcol)
        self.P = column_stack(collist)
        return self.P


    def acker(self, despoles):
        descoeffs = poly(despoles)
        phi = self.phi_des_of_A(descoeffs)
        P = self.controlability()
        Pinv = linalg.inv(P)
        en = zeros((1, self.N))
        en[0,-1] = 1.0
        M = dot(Pinv, phi)
        K = -1.0*dot(en, M)
        self.K = K
        return K


class SFLR_SS_model(SFLR_TF_models.SFLR_Time_File_Mixin_w_accel, SS_model):        
    def plot_model_data(self):
        SFLR_TF_models.SFLR_Time_File_Mixin_w_accel.plot_model_data(self)
        ax = self.ax
        t = self.t
        ax.plot(t, self.v, label='$v_{model}$')

    
    def calc_num(self):
        p_act1 = self.p_act1
        p_act2 = self.p_act2
        K_act = self.K_act
        H = self.H
        s1 = 1.0*2.0j*pi#magnitude of s at 1 Hz - fix this point for
        m1 = abs(s1*(s1+p_act1)*(s1+p_act2))
        self.num = K_act*m1#*m2

        
    def calc_coeffs(self):
        #This code is auto-generated by
        #/home/ryan/siue/Research/PSoC_Research/SFLR_2010/modeling/numeric_TMM_model/ss_from_ad_hoc_TF.py
        #--------------------------------
        #--------------------------------
        self.a_hat1 = self.p_act1*self.p_act2*self.wp1**2*self.wp2**2*self.wz1**2*self.wz2**2
        self.a_hat2 = self.p_act1*self.wp1**2*self.wp2**2*self.wz1**2*self.wz2**2 + self.p_act2*self.wp1**2*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.p_act2*self.wp1*self.zp1*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.p_act2*self.wp2*self.zp2*self.wp1**2*self.wz1**2*self.wz2**2
        self.a_hat3 = self.wp1**2*self.wp2**2*self.wz1**2*self.wz2**2 + self.p_act1*self.p_act2*self.wp1**2*self.wz1**2*self.wz2**2 + self.p_act1*self.p_act2*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.wp1*self.zp1*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.wp2*self.zp2*self.wp1**2*self.wz1**2*self.wz2**2 + 2*self.p_act2*self.wp1*self.zp1*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.p_act2*self.wp2*self.zp2*self.wp1**2*self.wz1**2*self.wz2**2 + 4*self.p_act1*self.p_act2*self.wp1*self.wp2*self.zp1*self.zp2*self.wz1**2*self.wz2**2
        self.a_hat4 = self.p_act1*self.wp1**2*self.wz1**2*self.wz2**2 + self.p_act1*self.wp2**2*self.wz1**2*self.wz2**2 + self.p_act2*self.wp1**2*self.wz1**2*self.wz2**2 + self.p_act2*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.wp1*self.zp1*self.wp2**2*self.wz1**2*self.wz2**2 + 2*self.wp2*self.zp2*self.wp1**2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.p_act2*self.wp1*self.zp1*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.p_act2*self.wp2*self.zp2*self.wz1**2*self.wz2**2 + 4*self.p_act1*self.wp1*self.wp2*self.zp1*self.zp2*self.wz1**2*self.wz2**2 + 4*self.p_act2*self.wp1*self.wp2*self.zp1*self.zp2*self.wz1**2*self.wz2**2
        self.a_hat5 = self.wp1**2*self.wz1**2*self.wz2**2 + self.wp2**2*self.wz1**2*self.wz2**2 + self.p_act1*self.p_act2*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.wp1*self.zp1*self.wz1**2*self.wz2**2 + 2*self.p_act1*self.wp2*self.zp2*self.wz1**2*self.wz2**2 + 2*self.p_act2*self.wp1*self.zp1*self.wz1**2*self.wz2**2 + 2*self.p_act2*self.wp2*self.zp2*self.wz1**2*self.wz2**2 + 4*self.wp1*self.wp2*self.zp1*self.zp2*self.wz1**2*self.wz2**2
        self.a_hat6 = self.p_act1*self.wz1**2*self.wz2**2 + self.p_act2*self.wz1**2*self.wz2**2 + 2*self.wp1*self.zp1*self.wz1**2*self.wz2**2 + 2*self.wp2*self.zp2*self.wz1**2*self.wz2**2
        self.a_hat7 = self.wz1**2*self.wz2**2
        self.b_th_hat0 = self.H*self.num*self.wp1**2*self.wp2**2*self.wz1**2*self.wz2**2
        self.b_th_hat1 = 2*self.H*self.num*self.wz1*self.zz1*self.wp1**2*self.wp2**2*self.wz2**2 + 2*self.H*self.num*self.wz2*self.zz2*self.wp1**2*self.wp2**2*self.wz1**2
        self.b_th_hat2 = self.H*self.num*self.wp1**2*self.wp2**2*self.wz1**2 + self.H*self.num*self.wp1**2*self.wp2**2*self.wz2**2 + 4*self.H*self.num*self.wz1*self.wz2*self.zz1*self.zz2*self.wp1**2*self.wp2**2
        self.b_th_hat3 = 2*self.H*self.num*self.wz1*self.zz1*self.wp1**2*self.wp2**2 + 2*self.H*self.num*self.wz2*self.zz2*self.wp1**2*self.wp2**2
        self.b_th_hat4 = self.H*self.num*self.wp1**2*self.wp2**2
        self.b_a_hat2 = self.B1*self.H*self.a_gain*self.num*self.wp1**2*self.wp2**2*self.wz2**2 + self.B2*self.H*self.a_gain*self.num*self.wp1**2*self.wp2**2*self.wz1**2
        self.b_a_hat3 = 2*self.B1*self.H*self.a_gain*self.num*self.wz2*self.zz2*self.wp1**2*self.wp2**2 + 2*self.B2*self.H*self.a_gain*self.num*self.wz1*self.zz1*self.wp1**2*self.wp2**2
        self.b_a_hat4 = self.B1*self.H*self.a_gain*self.num*self.wp1**2*self.wp2**2 + self.B2*self.H*self.a_gain*self.num*self.wp1**2*self.wp2**2

        self.a1 = self.a_hat1/self.a_hat7
        self.a2 = self.a_hat2/self.a_hat7
        self.a3 = self.a_hat3/self.a_hat7
        self.a4 = self.a_hat4/self.a_hat7
        self.a5 = self.a_hat5/self.a_hat7
        self.a6 = self.a_hat6/self.a_hat7
        self.b_th0 = self.b_th_hat0/self.a_hat7
        self.b_th1 = self.b_th_hat1/self.a_hat7
        self.b_th2 = self.b_th_hat2/self.a_hat7
        self.b_th3 = self.b_th_hat3/self.a_hat7
        self.b_th4 = self.b_th_hat4/self.a_hat7
        self.b_a2 = self.b_a_hat2/self.a_hat7
        self.b_a3 = self.b_a_hat3/self.a_hat7
        self.b_a4 = self.b_a_hat4/self.a_hat7
        #--------------------------------


    def set_zero_coeffs(self, prop_str):
        for i in range(self.N):
            cur_prop = prop_str + str(i)
            if not hasattr(self, cur_prop):
                setattr(self, cur_prop, 0.0)


    def build_matrices(self):
        self.A = zeros((self.N, self.N), dtype='float64')
        self.B = zeros((self.N,), dtype='float64')
        self.C = zeros((2, self.N), dtype='float64')

        self.B[-1] = 1.0

        for i in range(1, self.N):
            self.A[i-1,i] = 1.0

        for i in range(self.N):
            a_i_str = 'a' + str(i)
            a_i = getattr(self, a_i_str)
            self.A[-1,i] = -a_i

            b_th_i_str = 'b_th' + str(i)
            b_th_i = getattr(self, b_th_i_str)
            self.C[0,i] = b_th_i

            b_a_i_str = 'b_a' + str(i)
            b_a_i = getattr(self, b_a_i_str)
            self.C[1,i] = b_a_i


    def create_LTI(self):
        B2 = rwkmisc.colwise(self.B)
        nr, nc = self.C.shape
        self.lti1 = signal.lti(self.A, B2, self.C[0,:], 0)
        self.lti2 = signal.lti(self.A, B2, self.C[1,:], 0)

        

    def __init__(self, pklname, bode_opts=None, N=7):
        mydict = rwkmisc.LoadPickle(pklname)
        for key, value in mydict.iteritems():
            setattr(self, key, value)
        self.calc_num()
        self.calc_coeffs()
        self.N = N
        self.set_zero_coeffs('a')
        self.set_zero_coeffs('b_th')
        self.set_zero_coeffs('b_a')
        self.build_matrices()
        self.I = eye(N)
        self.bode_opts = bode_opts
        self.create_LTI()


    def calc_freq_resp_one_s(self, s_i):
        mat = s_i*self.I - self.A
        mati = linalg.inv(mat)
        M = dot(mati, self.B)
        comp = dot(self.C,M)
        return comp

        
    def calc_freq_resp(self, f):
        svect = 2.0j*pi*f
        comp_mat = zeros((2, len(svect)), dtype='complex128')

        for i, s_i in enumerate(svect):
            comp_i = self.calc_freq_resp_one_s(s_i)
            comp_mat[:,i] = comp_i
        self.comp_mat = comp_mat
        return comp_mat


    def find_opt(self, output, input):
        found = 0
        for opt in self.bode_opts:
            if (opt.output_label == output) and \
               (opt.input_label == input):
                found = 1
                return opt
        #if we got this far, we didn't find a match
        assert found, "Did not find a bode with output %s and input %s." % \
               (output, input)


    def find_bode(self, bodeopt):
        output = bodeopt.output_label
        input = bodeopt.input_label
        found = 0
        for bode in self.bodes:
            if (bode.output == output) and \
                   (bode.input == input):
                found = 1
                return bode
        #if we got this far, we didn't find a match
        assert found, "Did not find a bode with output %s and input %s." % \
               (output, input)


    def calc_bodes(self, f):
        comp_mat = self.calc_freq_resp(f)
        th_v_comp = comp_mat[0,:]
        a_v_comp = comp_mat[1,:]
        th_v_opts = self.find_opt('theta','v')
        self.th_v_bode = rwkbode.rwkbode(output='theta', \
                                         input='v', \
                                         compin=th_v_comp, \
                                         seedfreq=th_v_opts.seedfreq, \
                                         seedphase=th_v_opts.seedphase)
        self.th_v_bode.PhaseMassage(f)

        a_v_opts = self.find_opt('a','v')        
        self.a_v_bode = rwkbode.rwkbode(output='a', \
                                        input='v', \
                                        compin=a_v_comp, \
                                        seedfreq=a_v_opts.seedfreq, \
                                        seedphase=a_v_opts.seedphase)
        self.a_v_bode.PhaseMassage(f)
        self.bodes = [self.th_v_bode, self.a_v_bode]
        
#    def FreqResp(self, 


class closed_loop_SS_model(SFLR_SS_model):
    def calc_feeback_matrices(self, K, E=1.0):
        self.A_ol = copy.copy(self.A)
        B_temp = copy.copy(self.B)
        self.B_ol = rwkmisc.colwise(B_temp)
        self.K = rwkmisc.rowwise(K)
        self.E = E

        self.A = self.A_ol + dot(self.B_ol, self.K)
        if isscalar(E):
            self.B = self.B*E
        else:
            self.B = dot(self.B, E)

        self.create_LTI()
        
        return self.A, self.B


    def lsim2(self, U, T, X0=None, returnall=False, hmax=None):
        """Simulate output of a continuous-time linear system, using ODE solver.

        Inputs:

            system -- an instance of the LTI class or a tuple describing the
            system.  The following gives the number of elements in
            the tuple and the interpretation.
            2 (num, den)
            3 (zeros, poles, gain)
            4 (A, B, C, D)
        U -- an input array describing the input at each time T
            (linear interpolation is assumed between given times).
            If there are multiple inputs, then each column of the
            rank-2 array represents an input.
        T -- the time steps at which the input is defined and at which
            the output is desired.
        X0 -- (optional, default=0) the initial conditions on the state vector.

        Outputs: (T, yout, xout)

        T -- the time values for the output.
        yout -- the response of the system.
        xout -- the time-evolution of the state-vector.
        """
        # system is an lti system or a sequence
        #  with 2 (num, den)
        #       3 (zeros, poles, gain)
        #       4 (A, B, C, D)
        #  describing the system
        #  U is an input vector at times T
        #   if system describes multiple outputs
        #   then U can be a rank-2 array with the number of columns
        #   being the number of inputs

        # rather than use lsim, use direct integration and matrix-exponential.
        if hmax is None:
            hmax = T[1]-T[0]
        U = atleast_1d(U)
        T = atleast_1d(T)
        if len(U.shape) == 1:
            U = U.reshape((U.shape[0],1))
        sU = U.shape
        if len(T.shape) != 1:
            raise ValueError, "T must be a rank-1 array."
        if sU[0] != len(T):
            raise ValueError, "U must have the same number of rows as elements in T."
        if sU[1] != self.inputs:
            raise ValueError, "System does not define that many inputs."

        if X0 is None:
            X0 = zeros(self.B.shape[0],self.A.dtype)

        # for each output point directly integrate assume zero-order hold
        #   or linear interpolation.

        ufunc = interpolate.interp1d(T, U, kind='linear', axis=0, \
                                     bounds_error=False)

        def fprime(x, t, self, ufunc):
            return dot(self.A,x) + squeeze(dot(self.B,nan_to_num(ufunc([t]))))

        xout = integrate.odeint(fprime, X0, T, args=(self, ufunc), hmax=hmax)
        yout = dot(self.C,transpose(xout)) + dot(self.D,transpose(U))
        if returnall:
            return T, squeeze(transpose(yout)), xout
        else:
            return squeeze(transpose(yout))



    def lsim(self, u, t, interp=0, \
             returnall=False, X0=None, hmax=None):
        """Find the response of the TransferFunction to the input u
        with time vector t.  Uses signal.lsim.

        return y the response of the system."""
        try:
            out1 = signal.lsim(self.lti1, u, t, interp=interp, X0=X0)
            out2 = signal.lsim(self.lti2, u, t, interp=interp, X0=X0)
        except LinAlgError:
            #if the system has a pure integrator, lsim won't work.
            #Call lsim2.
            yout = self.lsim2(u, t, X0=X0, returnall=True, hmax=hmax)
            out1 = yout[:,0]
            out2 = yout[:,1]
                #override returnall because it is handled below
        self.theta = out1[1]
        self.accel = out2[1]
        self.x_theta = out1[2]
        self.x_accel = out2[2]

        self.v = squeeze(self.E*u + dot(self.K, self.x_theta.T))
        
        
        if returnall:#most users will just want the system output y,
            #but some will need the (t, y, x) tuple that
            #signal.lsim returns
            return out1, out2
        else:
            return out1[1], out2[1]

        
    def calc_bodes(self, f):
        comp_mat = self.calc_freq_resp(f)
        th_u_comp = comp_mat[0,:]
        a_u_comp = comp_mat[1,:]
        th_u_opts = self.find_opt('theta','u')
        self.th_u_bode = rwkbode.rwkbode(output='theta', \
                                         input='u', \
                                         compin=th_u_comp, \
                                         seedfreq=th_u_opts.seedfreq, \
                                         seedphase=th_u_opts.seedphase)
        self.th_u_bode.PhaseMassage(f)

        a_u_opts = self.find_opt('a','u')        
        self.a_u_bode = rwkbode.rwkbode(output='a', \
                                        input='u', \
                                        compin=a_u_comp, \
                                        seedfreq=a_u_opts.seedfreq, \
                                        seedphase=a_u_opts.seedphase)
        self.a_u_bode.PhaseMassage(f)
        self.bodes = [self.th_u_bode, self.a_u_bode]
